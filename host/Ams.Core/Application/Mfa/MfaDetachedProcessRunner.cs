using System.Diagnostics;
using System.IO;
using System.Text;
using Ams.Core.Application.Processes;
using Ams.Core.Artifacts.Alignment;

namespace Ams.Core.Application.Mfa;

/// <summary>
/// Executes MFA commands in standalone PowerShell processes so multiple alignments can run concurrently.
/// </summary>
internal static class MfaDetachedProcessRunner
{
    public static async Task<MfaCommandResult> RunAsync(
        string subcommand,
        string? args,
        string? workingDirectory,
        string? workspaceRoot,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(subcommand))
        {
            throw new ArgumentException("Subcommand must be provided", nameof(subcommand));
        }

        var command = BuildCommand(subcommand, args);
        var normalizedWorkingDir = NormalizeWorkingDirectory(workingDirectory);
        var scriptPath = WriteScript(command, normalizedWorkingDir);

        try
        {
            var psi = new ProcessStartInfo(MfaProcessSupervisor.ResolvePwshExecutable())
            {
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                RedirectStandardInput = false,
                CreateNoWindow = true
            };

            psi.ArgumentList.Add("-ExecutionPolicy");
            psi.ArgumentList.Add("ByPass");
            psi.ArgumentList.Add("-NoLogo");
            psi.ArgumentList.Add("-NoProfile");
            psi.ArgumentList.Add("-File");
            psi.ArgumentList.Add(scriptPath);

            if (!string.IsNullOrWhiteSpace(workspaceRoot))
            {
                Directory.CreateDirectory(workspaceRoot);
                psi.Environment["MFA_ROOT_DIR"] = workspaceRoot;
            }

            using var process = new Process { StartInfo = psi, EnableRaisingEvents = false };
            var stdout = new List<string>();
            var stderr = new List<string>();

            process.Start();

            var stdoutTask = PumpStreamAsync(process.StandardOutput, stdout);
            var stderrTask = PumpStreamAsync(process.StandardError, stderr);

            using var killRegistration = cancellationToken.Register(() =>
            {
                try
                {
                    if (!process.HasExited)
                    {
                        process.Kill(true);
                    }
                }
                catch
                {
                    // Ignore kill failures (process may have already exited).
                }
            });

            await process.WaitForExitAsync(cancellationToken).ConfigureAwait(false);
            await Task.WhenAll(stdoutTask, stderrTask).ConfigureAwait(false);

            return new MfaCommandResult(command, process.ExitCode, stdout, stderr);
        }
        finally
        {
            TryDeleteScript(scriptPath);
        }
    }

    private static string BuildCommand(string subcommand, string? args)
    {
        var builder = new StringBuilder("mfa ");
        builder.Append(subcommand.Trim());

        if (!string.IsNullOrWhiteSpace(args))
        {
            builder.Append(' ');
            builder.Append(args.Trim());
        }

        return builder.ToString();
    }

    private static string? NormalizeWorkingDirectory(string? directory)
    {
        if (string.IsNullOrWhiteSpace(directory))
        {
            return null;
        }

        try
        {
            return Path.GetFullPath(directory);
        }
        catch
        {
            return directory;
        }
    }

    private static string WriteScript(string command, string? workingDirectory)
    {
        var scriptPath = Path.Combine(Path.GetTempPath(), $"ams-mfa-detached-{Guid.NewGuid():N}.ps1");
        var script = BuildScript(command, workingDirectory);
        File.WriteAllText(scriptPath, script, Encoding.UTF8);
        return scriptPath;
    }

    private static string BuildScript(string command, string? workingDirectory)
    {
        var bootstrap = MfaProcessSupervisor.ResolveBootstrapSequence();
        var builder = new StringBuilder();
        builder.AppendLine("# Auto-generated by AMS for detached MFA execution");
        builder.AppendLine("$ErrorActionPreference = 'Continue'");
        builder.AppendLine("$bootstrap = @'");
        builder.AppendLine(bootstrap);
        builder.AppendLine("'@");
        builder.AppendLine("try {");
        builder.AppendLine("    Invoke-Expression $bootstrap");
        builder.AppendLine("} catch {");
        builder.AppendLine("    Write-Error $_");
        builder.AppendLine("}");

        if (!string.IsNullOrWhiteSpace(workingDirectory))
        {
            var escaped = workingDirectory.Replace("'", "''");
            builder.AppendLine("try {");
            builder.AppendLine($"    Set-Location '{escaped}'");
            builder.AppendLine("} catch {");
            builder.AppendLine("    Write-Error $_");
            builder.AppendLine("}");
        }

        var escapedCommand = command.Replace("'", "''");
        builder.AppendLine("$global:LASTEXITCODE = 0");
        builder.AppendLine("try {");
        builder.AppendLine($"    Invoke-Expression '{escapedCommand}'");
        builder.AppendLine("    $exitCode = if ($LASTEXITCODE) { $LASTEXITCODE } else { 0 }");
        builder.AppendLine("} catch {");
        builder.AppendLine("    Write-Error $_");
        builder.AppendLine("    $exitCode = if ($LASTEXITCODE) { $LASTEXITCODE } else { 1 }");
        builder.AppendLine("}");
        builder.AppendLine("exit $exitCode");

        return builder.ToString();
    }

    private static void TryDeleteScript(string scriptPath)
    {
        try
        {
            if (File.Exists(scriptPath))
            {
                File.Delete(scriptPath);
            }
        }
        catch
        {
            // Best-effort cleanup.
        }
    }

    private static Task PumpStreamAsync(StreamReader reader, List<string> sink)
    {
        return Task.Run(async () =>
        {
            string? line;
            while ((line = await reader.ReadLineAsync().ConfigureAwait(false)) is not null)
            {
                lock (sink)
                {
                    sink.Add(line);
                }
            }
        });
    }
}