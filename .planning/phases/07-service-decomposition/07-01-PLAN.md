---
phase: 07-service-decomposition
plan: 01
type: execute
---

<objective>
Extract AnchorComputeService from AlignmentService god class.

Purpose: Begin AlignmentService decomposition by extracting anchor computation logic into a focused service.
Output: New AnchorComputeService with ComputeAnchorsAsync, AlignmentService delegating to it.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior decisions affecting this phase:**
- AUD-003: AlignmentService decomposition approved as DO NOW (Phase 4 decision)
- ChapterLabelResolver already extracted in Phase 6 (prerequisite met)

**Issues being addressed:**
- AUD-003: AlignmentService god class (681 lines -> target <100 lines after full decomposition)

**Current state:**
- AlignmentService.cs: 641 lines with 3 major responsibilities
- ComputeAnchorsAsync: lines 25-55 (anchor computation)
- BuildPolicy: lines 169-182 (policy construction)
- BuildAnchorDocument: lines 184-225 (document building)

**Relevant source files:**
@host/Ams.Core/Services/Alignment/AlignmentService.cs
@host/Ams.Core/Services/Interfaces/IAlignmentService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AnchorComputeService</name>
  <files>host/Ams.Core/Services/Alignment/IAnchorComputeService.cs, host/Ams.Core/Services/Alignment/AnchorComputeService.cs</files>
  <action>
Create new focused service for anchor computation:

1. Create `IAnchorComputeService.cs`:
```csharp
public interface IAnchorComputeService
{
    Task<AnchorDocument> ComputeAnchorsAsync(
        ChapterContext context,
        AnchorComputationOptions? options = null,
        CancellationToken cancellationToken = default);
}
```

2. Create `AnchorComputeService.cs`:
- Copy `ComputeAnchorsAsync` method from AlignmentService (lines 25-55)
- Copy `BuildPolicy` method (lines 169-182)
- Copy `BuildAnchorDocument` method (lines 184-225)
- Copy `RequireBookAndAsr` helper (lines 162-167) - will be shared, keep private copy for now
- Add constructor with no dependencies (matches current AlignmentService pattern)
- Add static Logger field matching AlignmentService pattern

Keep same method signatures and behavior - this is a pure extraction refactor.
  </action>
  <verify>
- `dotnet build host/Ams.Core` succeeds
- New files exist with correct namespaces
  </verify>
  <done>
- IAnchorComputeService.cs created with ComputeAnchorsAsync signature
- AnchorComputeService.cs created with extracted methods
- Build succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update AlignmentService to delegate anchor computation</name>
  <files>host/Ams.Core/Services/Alignment/AlignmentService.cs</files>
  <action>
Refactor AlignmentService to delegate to AnchorComputeService:

1. Add IAnchorComputeService dependency:
- Add `private readonly IAnchorComputeService _anchorService;` field
- Update constructor to accept `IAnchorComputeService? anchorService = null`
- Default to `new AnchorComputeService()` if null (maintains backward compatibility)

2. Replace ComputeAnchorsAsync implementation:
- Keep the method signature (IAlignmentService contract unchanged)
- Delegate to `_anchorService.ComputeAnchorsAsync(context, options, cancellationToken)`

3. Remove extracted methods from AlignmentService:
- Remove `BuildPolicy` (now in AnchorComputeService)
- Remove `BuildAnchorDocument` (now in AnchorComputeService)
- Keep `RequireBookAndAsr` for now (still used by BuildTranscriptIndexAsync)

4. Update BuildTranscriptIndexAsync:
- It calls BuildPolicy and BuildAnchorDocument internally
- For now, create local copies or inline the logic (will be extracted in 07-02)
- Alternative: keep BuildPolicy/BuildAnchorDocument as internal methods until 07-02

Choose the simpler path: keep BuildPolicy and BuildAnchorDocument as private methods in AlignmentService for now since BuildTranscriptIndexAsync uses them. They will be properly extracted in 07-02.

Net change for this task: ComputeAnchorsAsync delegates to new service.
  </action>
  <verify>
- `dotnet build host/Ams.Core` succeeds
- `dotnet test host/Ams.Tests` passes all tests
- AlignmentService.ComputeAnchorsAsync now delegates to AnchorComputeService
  </verify>
  <done>
- AlignmentService injects IAnchorComputeService
- ComputeAnchorsAsync delegates to injected service
- IAlignmentService contract unchanged (backward compatible)
- All 60 tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build host/Ams.Core` succeeds with 0 errors
- [ ] `dotnet test host/Ams.Tests` passes all 60 tests
- [ ] New AnchorComputeService exists and compiles
- [ ] AlignmentService delegates anchor computation correctly
</verification>

<success_criteria>
- AnchorComputeService extracted with ComputeAnchorsAsync
- AlignmentService delegates to new service
- No breaking changes to IAlignmentService contract
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-service-decomposition/07-01-SUMMARY.md`
</output>
