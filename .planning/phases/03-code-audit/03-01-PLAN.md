---
phase: 03-code-audit
plan: 01
type: execute
---

<objective>
Identify dead code in the AMS codebase: orphaned files with no callers, unused methods, and potentially obsolete code paths.

Purpose: Create a comprehensive inventory of code that can be safely removed or needs investigation before removal.
Output: DEAD-CODE.md cataloguing all identified dead code with confidence levels and removal recommendations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Phase 1 artifacts (foundation for this analysis):**
@.planning/phases/01-discovery/FILE-INVENTORY.md
@.planning/phases/01-discovery/CALLGRAPH-INVENTORY.md
@.planning/phases/01-discovery/CALLGRAPH-GAPS.md
@.planning/phases/01-discovery/DISCOVERY-SYNTHESIS.md

**Prior decisions affecting this phase:**
- 146 source files confirmed (FILE-INVENTORY.md is source of truth)
- Call graph coverage is 90.4% (132/146 files mapped)
- FFmpeg files documented separately in FFMPEG-CALLGRAPH.md
- Projects classified as Active/Dormant/Stale/Nascent in PROJECT-STATUS.md

**Flagged dead code candidates (from DISCOVERY-SYNTHESIS.md):**
- `DspDemoRunner.cs` - Demo only, no production callers
- `FeatureExtraction.cs` - Breath detection may be disabled
- `Whisper.NET` files - Possibly superseded by Nemo ASR
</context>

<tasks>

<task type="auto">
  <name>Task 1: Orphaned file analysis</name>
  <files>.planning/phases/03-code-audit/ORPHANED-FILES.md</files>
  <action>
Cross-reference FILE-INVENTORY.md with CALLGRAPH-INVENTORY.md to identify files that:
1. Have no incoming calls (nothing calls into them)
2. Are not entry points (Program.cs, test files, etc.)
3. Are not configuration/model files (DTOs, options classes)

For each orphaned file candidate:
- Verify by searching codebase for references to the class/namespace
- Check if it's referenced via reflection or DI registration
- Categorize confidence: HIGH (definitely unused), MEDIUM (likely unused), LOW (needs investigation)

Output format:
```markdown
# Orphaned Files Analysis

## Definitely Orphaned (HIGH confidence)
| File | Last Modified | Reason | Recommendation |
|------|--------------|--------|----------------|

## Likely Orphaned (MEDIUM confidence)
| File | Last Modified | Reason | Investigation Needed |
|------|--------------|--------|---------------------|

## Uncertain (LOW confidence)
| File | Last Modified | Reason | Why Uncertain |
|------|--------------|--------|---------------|
```
  </action>
  <verify>ORPHANED-FILES.md exists with at least the three sections; each file listed has been verified by grep/search</verify>
  <done>All 146 files checked against call graphs; orphaned candidates categorized by confidence level</done>
</task>

<task type="auto">
  <name>Task 2: Unused method scan</name>
  <files>.planning/phases/03-code-audit/UNUSED-METHODS.md</files>
  <action>
Using CALLGRAPH-GAPS.md and CALLGRAPH-INVENTORY.md, identify methods that:
1. Are public but have no callers outside their own class
2. Are in active projects (Ams.Core, Ams.Cli) but appear in gap analysis
3. Look like they were once used but are now orphaned

Focus on high-value targets:
- Methods in service classes (likely meant to be called)
- Public API surface that's never invoked
- Helper methods that lost their callers

Do NOT flag:
- Interface implementations (may be called via interface)
- Virtual/override methods (polymorphic dispatch)
- Event handlers (called via reflection)
- Test helper methods

Output format:
```markdown
# Unused Methods Analysis

## Summary
- Total methods scanned: X
- Unused public methods: Y
- Unused internal methods: Z

## By Project

### Ams.Core
| Class | Method | Visibility | Last Caller Removed? | Recommendation |
|-------|--------|------------|---------------------|----------------|

### Ams.Cli
| Class | Method | Visibility | Last Caller Removed? | Recommendation |
|-------|--------|------------|---------------------|----------------|
```
  </action>
  <verify>UNUSED-METHODS.md exists with summary counts and per-project breakdown</verify>
  <done>Public and internal methods in active projects analyzed; unused methods catalogued with recommendations</done>
</task>

<task type="auto">
  <name>Task 3: Obsolete code catalogue</name>
  <files>.planning/phases/03-code-audit/DEAD-CODE.md</files>
  <action>
Investigate the three flagged dead code candidates and search for additional obsolete code:

**1. Whisper.NET vs Nemo ASR:**
- Check if Whisper.NET files are still used or if Nemo has fully replaced them
- Search for WhisperService, WhisperProcessor references
- Determine: Can Whisper.NET be removed?

**2. DspDemoRunner.cs:**
- Verify it's only used for demos/testing
- Check if any production code path invokes it
- Determine: Safe to remove or move to analysis/?

**3. FeatureExtraction.cs:**
- Check breath detection usage
- Verify if this feature is disabled or deprecated
- Determine: Remove, keep, or refactor?

**4. Additional obsolete code search:**
- Look for TODO/HACK/OBSOLETE comments
- Check for #if DEBUG blocks that are always-off
- Identify any "V1" or "Old" prefixed classes

Synthesize findings from Tasks 1-2 into final catalogue:

Output format:
```markdown
# Dead Code Catalogue

## Executive Summary
- Total orphaned files: X
- Total unused methods: Y
- Recommended removals: Z files, W methods
- Estimated lines removable: N

## Obsolete Code Investigation

### Whisper.NET Status
[Analysis and recommendation]

### DspDemoRunner Status
[Analysis and recommendation]

### FeatureExtraction Status
[Analysis and recommendation]

### Other Obsolete Code
[Any additional findings]

## Complete Dead Code Inventory

### Files to Remove (HIGH confidence)
[Consolidated list from ORPHANED-FILES.md]

### Methods to Remove (HIGH confidence)
[Consolidated list from UNUSED-METHODS.md]

### Needs Investigation
[Items requiring human decision before removal]

## Removal Impact Analysis
- Dependencies that would break: [list]
- Test coverage affected: [list]
- Risk assessment: LOW/MEDIUM/HIGH
```
  </action>
  <verify>DEAD-CODE.md exists with executive summary, all three flagged candidates investigated, and consolidated inventory</verify>
  <done>Complete dead code catalogue with confidence levels, removal recommendations, and impact analysis</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ORPHANED-FILES.md exists with categorized file list
- [ ] UNUSED-METHODS.md exists with per-project breakdown
- [ ] DEAD-CODE.md exists with executive summary and consolidated inventory
- [ ] All three flagged candidates (Whisper, DspDemo, FeatureExtraction) investigated
- [ ] Recommendations are actionable (not vague)
</verification>

<success_criteria>
- All three deliverables created
- Every identified dead code item has confidence level
- Removal recommendations are specific and justified
- No false positives (interface implementations, event handlers incorrectly flagged)
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-audit/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Dead Code Inventory Summary

**[One-liner: e.g., "Identified X orphaned files and Y unused methods totaling ~Z lines of removable code"]**

## Accomplishments
- [Key findings]

## Files Created
- `ORPHANED-FILES.md` - Orphaned file analysis
- `UNUSED-METHODS.md` - Unused method scan
- `DEAD-CODE.md` - Consolidated dead code catalogue

## Key Findings
- [Most significant dead code discoveries]

## Next Step
Ready for 03-02-PLAN.md (Responsibility Analysis)
</output>
