---
phase: 02-pipeline-analysis
plan: 01
type: execute
---

<objective>
Document the exact orchestration flow of PipelineService.RunChapterAsync, including command execution order, dependencies between stages, and concurrency control patterns.

Purpose: Establish crystal-clear understanding of how the pipeline orchestrates ASR → alignment → MFA → merge stages.
Output: PIPELINE-ORCHESTRATION.md documenting method call sequence, command order, and concurrency patterns.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Phase 1 Discovery findings (critical context):**
@.planning/phases/01-discovery/CALLGRAPH-INSIGHTS.md
@.planning/phases/01-discovery/DISCOVERY-SYNTHESIS.md

**Key source files to trace:**
@host/Ams.Core/Application/Services/PipelineService.cs
@host/Ams.Core/Application/Commands/GenerateTranscriptCommand.cs
@host/Ams.Core/Application/Commands/ComputeAnchorsCommand.cs
@host/Ams.Core/Application/Commands/BuildTranscriptIndexCommand.cs
@host/Ams.Core/Application/Commands/HydrateTranscriptCommand.cs
@host/Ams.Core/Application/Commands/RunMfaCommand.cs
@host/Ams.Core/Application/Commands/MergeTimingsCommand.cs

**Prior decisions affecting this phase:**
- PipelineService.RunChapterAsync is the main orchestrator (30+ callees identified in Phase 1)
- 6 command classes coordinate the pipeline stages
- Context hierarchy: BookContext → ChapterContext → ChapterContextHandle

**From Phase 1 Open Questions:**
- What is the exact flow through PipelineService.RunChapterAsync?
- How does error handling work across the pipeline?
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trace PipelineService.RunChapterAsync execution flow</name>
  <files>.planning/phases/02-pipeline-analysis/PIPELINE-ORCHESTRATION.md</files>
  <action>
    Read PipelineService.cs and trace the RunChapterAsync method:
    1. Document the exact sequence of method calls
    2. Identify conditional branches (what triggers different paths)
    3. Note where semaphores/locks are acquired and released
    4. Document the order commands are invoked
    5. Capture any early-exit conditions or validation checks

    Create PIPELINE-ORCHESTRATION.md with:
    - Method signature and entry conditions
    - Step-by-step execution trace
    - Mermaid sequence diagram of the flow
  </action>
  <verify>PIPELINE-ORCHESTRATION.md exists and contains method trace with sequence diagram</verify>
  <done>Complete execution flow documented from entry to exit</done>
</task>

<task type="auto">
  <name>Task 2: Map command execution order and dependencies</name>
  <files>.planning/phases/02-pipeline-analysis/PIPELINE-ORCHESTRATION.md</files>
  <action>
    For each of the 6 commands called by PipelineService, document:
    1. Execution order (which commands run first)
    2. Dependencies (what must complete before this command runs)
    3. What each command produces (output artifacts)
    4. What each command consumes (input requirements)

    Read each command's ExecuteAsync method to understand its role.

    Add to PIPELINE-ORCHESTRATION.md:
    - Command dependency table
    - Execution order diagram
    - Input/output summary per command
  </action>
  <verify>All 6 commands documented with order, dependencies, and I/O</verify>
  <done>Command execution matrix complete showing order and dependencies</done>
</task>

<task type="auto">
  <name>Task 3: Document concurrency control patterns</name>
  <files>.planning/phases/02-pipeline-analysis/PIPELINE-ORCHESTRATION.md</files>
  <action>
    Trace how PipelineService manages concurrency:
    1. Identify all semaphores/locks used
    2. Document what operations are parallelizable
    3. Document what operations must be sequential
    4. Note any async/await patterns that affect ordering
    5. Identify potential bottlenecks or contention points

    Add to PIPELINE-ORCHESTRATION.md:
    - Concurrency control section
    - Parallelism boundaries diagram
    - Potential bottleneck notes
  </action>
  <verify>Concurrency patterns documented with parallelism boundaries</verify>
  <done>Concurrency model fully documented including semaphores and parallelism boundaries</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] PIPELINE-ORCHESTRATION.md exists in .planning/phases/02-pipeline-analysis/
- [ ] Contains complete RunChapterAsync execution trace
- [ ] Contains Mermaid sequence diagram
- [ ] All 6 commands documented with order and dependencies
- [ ] Concurrency control patterns documented
- [ ] No gaps in the execution flow
</verification>

<success_criteria>
- Complete execution flow documented from PipelineService entry to exit
- All 6 pipeline commands mapped with execution order
- Concurrency patterns identified (semaphores, parallelism)
- Sequence diagram shows the full orchestration flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-pipeline-analysis/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Pipeline Orchestration Summary

**[Substantive one-liner about pipeline flow]**

## Performance
- Duration: X min
- Tasks: 3

## Accomplishments
- [Key findings about orchestration]

## Files Created
- PIPELINE-ORCHESTRATION.md - [size]

## Key Findings
- [Pipeline execution order]
- [Concurrency patterns]
- [Dependencies between stages]

## Next Step
Ready for 02-02-PLAN.md (Data Flow & Artifacts)
</output>
