---
phase: 06-utility-extraction
plan: 04
type: execute
---

<objective>
Consolidate ASR buffer preparation by creating AsrAudioPreparer utility and unifying the two different downmix implementations.

Purpose: Eliminate code duplication between AsrService (FFmpeg-based) and AsrProcessor (simple averaging), creating a single source of truth for ASR audio preparation.
Output: New AsrAudioPreparer.cs utility with unified implementation, both callers updated to use it.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-recommendations/ACTION-LIST.md

**Prior decisions:**
- AUD-013: ASR buffer prep split between two implementations - CONSOLIDATE

**Current state - two different implementations:**

1. AsrService.cs (high quality, FFmpeg-based):
   - `PrepareForAsr()` - uses FfFilterGraph for channel downmix
   - `BuildMonoPanClause()` - generates FFmpeg pan filter

2. AsrProcessor.cs (lower quality, simple averaging):
   - `NormalizeBuffer()` - calls DownmixToMono
   - `DownmixToMono()` - simple per-sample averaging

**Files:**
@host/Ams.Core/Services/AsrService.cs
@host/Ams.Core/Processors/AsrProcessor.cs

**Target:** Single AsrAudioPreparer utility that:
- Uses FFmpeg when available (high quality)
- Falls back to simple averaging when FFmpeg unavailable
- Handles both downmix and sample rate conversion
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AsrAudioPreparer utility</name>
  <files>host/Ams.Core/Audio/AsrAudioPreparer.cs</files>
  <action>
    1. Create `host/Ams.Core/Audio/AsrAudioPreparer.cs`

    2. Add namespace `Ams.Core.Audio`

    3. Create static class `AsrAudioPreparer` with:

       a. Main method:
       ```csharp
       /// <summary>
       /// Prepares an audio buffer for ASR by converting to mono and resampling to 16kHz.
       /// Uses FFmpeg filter graph when available for high-quality conversion,
       /// falls back to simple averaging otherwise.
       /// </summary>
       public static AudioBuffer PrepareForAsr(AudioBuffer buffer)
       ```

       b. Move from AsrService.cs:
          - `BuildMonoPanClause(int channels)` - FFmpeg pan filter clause generation

       c. Add from AsrProcessor.cs (as fallback):
          - `DownmixToMonoSimple(AudioBuffer buffer)` - simple averaging implementation

       d. Logic flow:
          ```
          if (buffer.Channels == 1 && buffer.SampleRate == 16000)
              return buffer; // Already ready

          if (FfSession.FiltersAvailable)
              Use FFmpeg filter graph (high quality)
          else
              Use DownmixToMonoSimple fallback

          if (buffer.SampleRate != 16000)
              Resample using AudioProcessor.Resample
          ```

    4. Add XML documentation explaining:
       - Purpose: prepare audio for ASR engines (Whisper, Nemo)
       - FFmpeg path: higher quality, uses proper pan filter
       - Fallback path: simple averaging, works without FFmpeg

    5. Add required using statements:
       - `using Ams.Core.Artifacts;`
       - `using Ams.Core.Processors;`
       - `using Ams.Core.Services.Integrations.FFmpeg;`
  </action>
  <verify>
    - File exists at host/Ams.Core/Audio/AsrAudioPreparer.cs
    - `dotnet build host/Ams.Core` succeeds
    - Has both FFmpeg path and fallback path
  </verify>
  <done>AsrAudioPreparer.cs created with unified PrepareForAsr implementation supporting FFmpeg and fallback paths</done>
</task>

<task type="auto">
  <name>Task 2: Update callers to use AsrAudioPreparer</name>
  <files>host/Ams.Core/Services/AsrService.cs, host/Ams.Core/Processors/AsrProcessor.cs</files>
  <action>
    1. In AsrService.cs:
       - Add `using Ams.Core.Audio;`
       - Remove `PrepareForAsr()` method (~12 lines)
       - Remove `BuildMonoPanClause()` method (~21 lines)
       - Update `ResolveAsrReadyBuffer()` to call `AsrAudioPreparer.PrepareForAsr(buffer)`

    2. In AsrProcessor.cs:
       - Add `using Ams.Core.Audio;`
       - Remove `NormalizeBuffer()` method OR update to call AsrAudioPreparer
       - Remove `DownmixToMono()` method (~20 lines)
       - Update `TranscribeBufferInternalAsync()` to use AsrAudioPreparer

       Note: AsrProcessor also handles sample rate conversion. Ensure the unified
       AsrAudioPreparer handles both downmix AND resample, or keep Resample separate.

    3. Search for any other callers:
       ```
       grep -r "PrepareForAsr\|DownmixToMono\|NormalizeBuffer" host/ --include="*.cs"
       ```
       Update any additional callers found.

    4. Clean up unused imports in modified files
  </action>
  <verify>
    - `dotnet build host/Ams.Core` succeeds with 0 errors
    - `dotnet test host/Ams.Tests` passes (60/60 after previous plan, or 58/60 if 06-03 not yet run)
    - AsrService.cs reduced by ~33 lines
    - AsrProcessor.cs reduced by ~40 lines
    - grep for DownmixToMono only finds AsrAudioPreparer.cs
  </verify>
  <done>
    - AsrService uses AsrAudioPreparer.PrepareForAsr()
    - AsrProcessor uses AsrAudioPreparer.PrepareForAsr()
    - No duplicate downmix implementations remain
    - All tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build host/Ams.sln` succeeds with 0 errors
- [ ] `dotnet test host/Ams.Tests` passes
- [ ] AsrAudioPreparer.cs exists in host/Ams.Core/Audio/
- [ ] AsrService.cs no longer contains PrepareForAsr or BuildMonoPanClause
- [ ] AsrProcessor.cs no longer contains DownmixToMono
- [ ] Single source of truth for ASR audio preparation
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- ~73 lines of duplicate code eliminated
- ASR audio preparation consolidated to single utility
- Issue AUD-013 resolved
- Phase 6 complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-utility-extraction/06-04-SUMMARY.md`
</output>
